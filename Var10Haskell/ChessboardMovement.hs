checkMovement :: Int -> Int -> String -> String
-- Функция для проверки движения на доске
checkMovement n m s = checkMovement' 0 0 s -- Вызываем вспомогательную функцию с начальными координатами (0, 0) и строкой движений

  where
    checkMovement' :: Int -> Int -> String -> String
    -- Вспомогательная функция для проверки движения на доске
    checkMovement' x y [] = "(" ++ show x ++ "," ++ show y ++ ")" -- Если строка движений пустая, возвращаем текущие координаты в формате строки
    checkMovement' x y (move:rest)
      | x' < n `div` 2 && x' > -(n `div` 2) && y' < m `div` 2 && y' > -(m `div` 2) = checkMovement' x' y' rest -- Если новые координаты находятся в пределах доски, рекурсивно вызываем функцию для оставшейся части строки
      | otherwise = "No" -- Иначе, возвращаем "No", так как вышли за пределы доски
      where
        (x', y') = case move of
                     'L' -> (x - 1, y) -- Если команда 'L', двигаемся на одну клетку влево по горизонтали
                     'R' -> (x + 1, y) -- Если команда 'R', двигаемся на одну клетку вправо по горизонтали
                     'U' -> (x, y + 1) -- Если команда 'U', двигаемся на одну клетку вверх по вертикали
                     'D' -> (x, y - 1) -- Если команда 'D', двигаемся на одну клетку вниз по вертикали
                     _   -> error "Invalid Command" -- В случае некорректной команды выбрасываем ошибку

main :: IO ()
-- Главная функция программы
main = do
    input <- getLine -- Считываем строку ввода из стандартного ввода
    let [n, m, s] = words input -- Разбиваем строку на отдельные значения
    putStrLn $ checkMovement (read n) (read m) s -- Вызываем функцию checkMovement с прочитанными значениями и выводим результат


